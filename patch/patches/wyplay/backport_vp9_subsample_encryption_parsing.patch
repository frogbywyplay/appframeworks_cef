--- media/formats/webm/webm_crypto_helpers.cc	2017-11-23 19:42:43.790540048 +0000
+++ media/formats/webm/webm_crypto_helpers.cc	2017-11-23 21:14:01.599276531 +0000
@@ -24,6 +24,73 @@
   return counter_block;
 }
 
+uint32_t ReadInteger(const uint8_t* buf, int size) {
+  // Read in the big-endian integer.
+  uint32_t value = 0;
+  for (int i = 0; i < size; ++i)
+    value = (value << 8) | buf[i];
+  return value;
+}
+
+bool ExtractSubsamples(const uint8_t* buf,
+                       size_t frame_data_size,
+                       size_t num_partitions,
+                       std::vector<SubsampleEntry>* subsample_entries) {
+  subsample_entries->clear();
+  uint32_t clear_bytes = 0;
+  // Partition is the wall between alternating sections. Partition offsets are
+  // relative to the start of the actual frame data.
+  // Size of clear/cipher sections can be calculated from the difference between
+  // adjacent partition offsets.
+  // Here is an example with 4 partitions (5 sections):
+  //   "clear |1 cipher |2 clear |3 cipher |4 clear"
+  // With the first and the last implicit partition included:
+  //   "|0 clear |1 cipher |2 clear |3 cipher |4 clear |5"
+  //   where partition_offset_0 = 0, partition_offset_5 = frame_data_size
+  // There are three subsamples in the above example:
+  //   Subsample0.clear_bytes = partition_offset_1 - partition_offset_0
+  //   Subsample0.cipher_bytes = partition_offset_2 - partition_offset_1
+  //   ...
+  //   Subsample2.clear_bytes = partition_offset_5 - partition_offset_4
+  //   Subsample2.cipher_bytes = 0
+  uint32_t partition_offset = 0;
+  for (size_t i = 0, offset = 0; i <= num_partitions; ++i) {
+    const uint32_t prev_partition_offset = partition_offset;
+    partition_offset =
+        (i == num_partitions)
+            ? frame_data_size
+            : ReadInteger(buf + offset, kWebMEncryptedFramePartitionOffsetSize);
+    offset += kWebMEncryptedFramePartitionOffsetSize;
+    if (partition_offset < prev_partition_offset) {
+      DVLOG(1) << "Partition should not be decreasing " << prev_partition_offset
+               << " " << partition_offset;
+      return false;
+    }
+
+    uint32_t cipher_bytes = 0;
+    bool new_subsample_entry = false;
+    // Alternating clear and cipher sections.
+    if ((i % 2) == 0) {
+      clear_bytes = partition_offset - prev_partition_offset;
+      // Generate a new subsample when finishing reading partition offsets.
+      new_subsample_entry = i == num_partitions;
+    } else {
+      cipher_bytes = partition_offset - prev_partition_offset;
+      // Generate a new subsample after seeing a cipher section.
+      new_subsample_entry = true;
+    }
+
+    if (new_subsample_entry) {
+      if (clear_bytes == 0 && cipher_bytes == 0) {
+        DVLOG(1) << "Not expecting >2 partitions with the same offsets.";
+        return false;
+      }
+      subsample_entries->push_back(SubsampleEntry(clear_bytes, cipher_bytes));
+    }
+  }
+  return true;
+}
+
 }  // namespace anonymous
 
 bool WebMCreateDecryptConfig(const uint8_t* data,
@@ -37,13 +104,14 @@
     return false;
   }
 
-  uint8_t signal_byte = data[0];
+  const uint8_t signal_byte = data[0];
   int frame_offset = sizeof(signal_byte);
 
   // Setting the DecryptConfig object of the buffer while leaving the
   // initialization vector empty will tell the decryptor that the frame is
   // unencrypted.
   std::string counter_block;
+  std::vector<SubsampleEntry> subsample_entries;
 
   if (signal_byte & kWebMFlagEncryptedFrame) {
     if (data_size < kWebMSignalByteSize + kWebMIvSize) {
@@ -52,12 +120,36 @@
     }
     counter_block = GenerateWebMCounterBlock(data + frame_offset, kWebMIvSize);
     frame_offset += kWebMIvSize;
+
+    if (signal_byte & kWebMFlagEncryptedFramePartitioned) {
+      if (data_size < frame_offset + kWebMEncryptedFrameNumPartitionsSize) {
+        DVLOG(1) << "Got a partitioned encrypted block with not enough data "
+                 << data_size;
+        return false;
+      }
+
+      const size_t num_partitions = data[frame_offset];
+      frame_offset += kWebMEncryptedFrameNumPartitionsSize;
+      const uint8_t* partition_data_start = data + frame_offset;
+      frame_offset += kWebMEncryptedFramePartitionOffsetSize * num_partitions;
+      if (data_size <= frame_offset) {
+        DVLOG(1) << "Got a partitioned encrypted block with " << num_partitions
+                 << " partitions but not enough data " << data_size;
+        return false;
+      }
+      const size_t frame_data_size = data_size - frame_offset;
+      if (!ExtractSubsamples(partition_data_start, frame_data_size,
+                             num_partitions, &subsample_entries)) {
+        return false;
+      }
+    }
   }
 
+  LOG(INFO) << "num_subsamples=" << subsample_entries.size();
+
   decrypt_config->reset(new DecryptConfig(
       std::string(reinterpret_cast<const char*>(key_id), key_id_size),
-      counter_block,
-      std::vector<SubsampleEntry>()));
+      counter_block, subsample_entries));
   *data_offset = frame_offset;
 
   return true;
--- media/formats/webm/webm_constants.h	2017-11-23 20:17:14.086665600 +0000
+++ media/formats/webm/webm_constants.h	2017-11-23 20:18:55.386089065 +0000
@@ -209,8 +209,13 @@
 // Current encrypted WebM request for comments specification is here
 // http://wiki.webmproject.org/encryption/webm-encryption-rfc
 const uint8_t kWebMFlagEncryptedFrame = 0x1;
+const uint8_t kWebMFlagEncryptedFramePartitioned = 0x2;
 const int kWebMIvSize = 8;
 const int kWebMSignalByteSize = 1;
+const int kWebMEncryptedFrameNumPartitionsSize = 1;
+const int kWebMEncryptedFramePartitionOffsetSize = 4;
+
+
 
 // Current specification for WebVTT embedded in WebM
 // http://wiki.webmproject.org/webm-metadata/temporal-metadata/webvtt-in-webm
